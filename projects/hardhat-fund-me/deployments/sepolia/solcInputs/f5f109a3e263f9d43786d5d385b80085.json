{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/FundMe.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n//Aim: Get funds from users, withdraw funds, Set minimum funding value in USD\n\n/*Notes:\n    1. payable is a modifier that allows a function to accept and handle Ether\n    2. Smart contract can hold funds as well just like wallets\n    3. 1e18 is 10 to the power of 18. 1e18 is 1eth. The monis math is done in terms of Wei\n    4. require keyword is a checker. If condition is not satisfied, it reverts with an error\n    5. Revert undoes any action done before and sends remaining gas back\n    6. Blockchain Oracle is any device that interacts with the off-chain world to provide external data or computation to smart contracts\n    7. Centralized Oracles bad cause single point of failure. Decentralized Oracles (ChainLink as example) hella nice\n    8. Bruh, blockchain can't make HTTPS requests apparently. Crazy\n    9. ABI is basically a translator between external applications and smart contracts which help format data so that it is readable for both the application and EVM.\n    10. Interface defines a set of functions without their implementation (like a blueprint) where the developer has to specify the implentation of those functions in their smart contract. This is what interface is in ABI as well. We get to know the functions and input to functions that we can use for a smart contract.\n    11. msg.value and msg.sender are global variables. msg.value gives how much native blockchain currency is being sent and msg.sender is the address of whoever calls the function (fund in this case)\n    12. Decimals / floating point math doesn't work in Solidity\n    13. msg.value.getConversion() is same as getConversion(msg.value) in case of library. We're sending the object as the first parameter. If there are more than one parameters, we write the other ones inside the parenthesis\n    14. new address[](0) --> new array of addresses with 0 elements inside array.\n    15. 3 ways to send ether to other contracts: Transfer, Send, Call ; More info here: https://solidity-by-example.org/sending-ether/\n    16. Modifiers are contract-level declarations which allow us to inject reusable logic into function calls. The _; tells the function to run the rest of the code.\n    17. constant and immutable are keywords which ensure that a variable cannot be changed. Helps lessen the gas\n    18. We can add constant keyword if the variable declared is constant from compile time\n    19. Nice habit to have immutable variable names start with i_\n    20. We can do custom errors in Solidty above 0.8.4\n    21. revert does exactly what require does without checking any conditionals.\n    22. recieve() and fallback() are special functions that we can use when someone does not call any functions but still sends token to our contract through let's say a wallet like Metamask.\n    23. For constant keyword, we have to know value while writing code. For immutable keyword, we can assign the value dynamically only once in the constructor.\n\n*/\n\nimport \"./PriceConverter.sol\";\n\nerror NotOwner();\n\ncontract FundMe {\n\n    using PriceConverter for uint256;\n\n    uint256 public constant MINIMUM_USD = 50 * 1e18;\n\n    address[] public funders;\n    mapping(address => uint256) public addressToAmtFunded;\n\n    address public immutable i_owner;\n\n    AggregatorV3Interface public priceFeed;\n    \n    constructor(address priceFeedAddr) {\n        i_owner = msg.sender;\n        priceFeed = AggregatorV3Interface(priceFeedAddr);\n    }\n\n    function fund() public payable {\n        require(msg.value.getConversion(priceFeed) >= MINIMUM_USD, \"Value is less than the minimum\");\n        funders.push(msg.sender);\n        addressToAmtFunded[msg.sender] = msg.value;\n\n    }\n\n\n    function withdraw() public onlyOwner {\n\n            for (uint256 funderIndex = 0 ; funderIndex < funders.length ; funderIndex++) {\n                address funder = funders[funderIndex];\n                addressToAmtFunded[funder] = 0;\n            }\n\n            funders = new address[](0);\n\n            // //1. TRASNFER\n            // //this over here refers to the smart contract\n            // //msg.sender is of type address. We typecast it to payable address to be able to send a token\n            // //If more than 2300 gas is required, transfer() will throw an error\n            // payable(msg.sender).transfer(address(this).balance);\n\n            // //2. SEND\n            // // if more than 2300 gas is required, send() will return a bool\n            // bool sendSucess = payable(msg.sender).send(address(this).balance);\n            // require(sendSucess, \"Send fail\");\n\n\n            //3. CALL\n            (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n            require(callSuccess, \"Call fail\");\n\n     }\n\n     modifier onlyOwner {\n        //  require(msg.sender == i_owner, \"Sender is not owner\");\n\n        if (msg.sender != i_owner) {\n            revert NotOwner();\n        }\n         _;\n     }\n\n     // If someone ETH to this contract without using the fund function, we wouldn't be able to keep track of the funder as we stated in fund function.\n     //To solve that:\n     receive() external payable {\n         fund();\n     }\n\n    fallback() external payable {\n        fund();\n    }\n\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\n/*Notes:\n    1. Library are similiar to contracts except can't declare a state variable and can't send ether to it.\n    2. All functions inside library need to be internal\n    3. \n\n*/\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n    function getPrice(AggregatorV3Interface priceFeed) view internal returns (uint256) {\n\n        //AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);\n\n        //We only want price, so we can remove the other return types but keep the commas\n        ( , int256 price, , , ) = priceFeed.latestRoundData();\n\n        //price is ETH price in terms of USD\n        //price has 8 decimal values whereas msg.value has 18 decimal places because of different units. So let's get the decimal places to be same. Also msg.value is of type uint256 whereas price is int256, so we will perform type casting too.\n        return uint256(price * 1e10);\n\n\n    }\n\n    function getConversion(uint256 ethAmt, AggregatorV3Interface priceFeed) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmtUSD = (ethPrice * ethAmt) / 1e18;\n        return ethAmtUSD;\n     }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}